#! /bin/bash
VERSION="1.2"

function showVersion {
    echo "watchface v${VERSION}"
}

function showHelp {
    showVersion
    cat << EOF
watchface [option] [command...]
Utility functions for AsteroidOS watchfaces.  By default, uses "SSH Mode"
over ssh, but can also use "ADB Mode" using ADB.

Available options:
-h or --help            print this help screen and quit
-a or --adb             use ADB command to communicate with watch
-b or --boot            reboot watch after deploying multiple watchfaces
-c or --circlewall WP   set the wallpaper for circular watchface thumbnail to the named file (WP)
-e or --every           select every watchface (deploy only)
-g or --gui             use the GTK+ gui
-p or --port            specify an IP port to use for ssh and scp commands
-q or --qemu            communicate with QEMU emulated watch (same as -r localhost -p 2222 )
-r or --remote          specify the remote (watch)  name or address for ssh and scp commands
-t or --transport       when used win ADB mode, specifies the transport id
-w or --wall WP         set the wallpaper for deploy or test to the named file (WP)
-v or --verbose         print verbose messages (useful for debugging)

Available commands:
update          use git to update your local copy of the unoffical-watchfaces repository
version         display the version of this program and exit
deploy WF       push the named watchface to the watch and activate it
deployall       deploy all watchfaces
clone WF NEWWF  clone the named watchface WF to new watchface NEWWF
test WF         test the named watchface on the computer using qmlscene

EOF
}


# Environment variables which are set based on
# parsed command line switches

# These are the defaults for SSH access
WATCHPORT=22
WATCHADDR=192.168.2.15
# These are the defaults for local QEMU target
QEMUPORT=2222
QEMUADDR=localhost
# Assume no ADB unless told otherwise
ADB=false
# Assume no GUI unless told otherwise
GUI=false
# Only show interactive prompt if the user hasn't
# already specified a command on the command line
SKIP_INTERACTIVE_PROMPT=false
# No wallpaper unless asked
WALLPAPER=""
WALLPAPER_ROUND=""
# Default to all watchfaces unselected for deploy
DEFAULTOPTION=OFF
# Default to not deploying all watchfaces
DEPLOY_ALL=false
# Print verbose messages to stderr
VERBOSE_MESSAGES=false
# Transport id is not needed; only one watch
TRANSPORT_ID=

# Command to execute
COMMAND=""
# Arguments for the command
declare -a COMMAND_ARGS=()


function runWatchCommand {
    local user="$1"
    local cmd=$2
    case ${user} in
        root)
            if [ "$ADB" = "true" ] ; then
                adb ${TRANSPORT_ID} shell "${cmd}"
            else
                ssh -p "${WATCHPORT}" -t root@"${WATCHADDR}" ${cmd}
            fi
            ;;
        ceres)
            if [ "$ADB" = "true" ] ; then
                printf -v cmd %q "${cmd}"
                adb ${TRANSPORT_ID} shell "su -l -c ${cmd} ceres"
            else
                ssh -p "${WATCHPORT}" -t ceres@"${WATCHADDR}" ${cmd}
            fi
            ;;
        *)
            echo "Error: unknown watch user ${user}"
            ;;
    esac
}

function printVerbose {
   local message="$1"
   if [ "${VERBOSE_MESSAGES}" = "true" ] ; then
       echo "$message"
   fi
}

function setDconf {
    local dconfsetting="$1"
    local filename="$2"
    runWatchCommand "ceres" "dconf write ${dconfsetting} '\"file://${filename}\"'"
}

function pushFiles {
    local user="$1"
    local sourcedir="$2"
    local destdir="$3"
    if [ "$ADB" = "true" ] ; then
        adb ${TRANSPORT_ID} push ${sourcedir} "${destdir}"
    else
        scp -P"${WATCHPORT}" -r ${sourcedir} "${user}@${WATCHADDR}:${destdir}"
    fi
}

function pushWatchface {
    pushFiles "root" "${1}"'/usr/share/*' "/usr/share/"
}

function pushWallpaper {
    local source="$1"
    local wallpaper
    wallpaper="$(basename "$1")"
    local destination="/usr/share/asteroid-launcher/wallpapers/full/${wallpaper}"
    pushFiles "root" "${source}" "${destination}"
    setDconf "/desktop/asteroid/background-filename" "${destination}"
}

function restartCeres {
    runWatchCommand "ceres" "killall asteroid-launcher"
}

function rebootWatch {
    runWatchCommand "ceres" "reboot"
}

function activateWatchface {
    setDconf "/desktop/asteroid/watchface" "/usr/share/asteroid-launcher/watchfaces/${1}.qml"
}

function watchfaceClone {
    local files
    mapfile -t files <<<"$(find . -path './'"$1"'/*' -type f | awk '{ dst=$0 ; gsub(/'"$1"'/,"'"$2"'",dst);  print $0 "|" dst }')"
    for filepair in "${files[@]}" ; do
        IFS="|" read -r -a srcDstPaths <<< "${filepair}"
        #echo "Copying from ${srcDstPaths[0]} to ${srcDstPaths[1]}"
        destdir="${srcDstPaths[1]%/*}"
        extension="${srcDstPaths[1]##*.}"
        mkdir -p "${destdir}"
        cp "${srcDstPaths[0]}" "${srcDstPaths[1]}"
        if [ "${extension}" = "qml" ] ; then
            sed -i "s/$1/$2/g" "${srcDstPaths[1]}"
        fi
    done
}

function sanitizeSourceWatchface {
    # trim trailing / if present
    local face="${1%/*}"
    if [[ "x${face}" = "x" ]] ; then
        echo "Error: no watchface specified" >&2
        exit 1
    fi
    if [[ ! -d "${face}/usr/share/asteroid-launcher/watchfaces/" ]] ; then
        echo "Error: \"${face}\" does not appear to be a watchface" >&2
        exit 1
    fi
    echo "${face}"
}

function deployface {
    local sourcewatchface
    local activate="$2"
    if ! sourcewatchface=$(sanitizeSourceWatchface "$1") ; then
        exit 1
    fi
    echo "Deploying ${sourcewatchface}"
    pushWatchface "${sourcewatchface}"
    if [ "${activate}" = "true" ] ; then
        activateWatchface "${sourcewatchface}"
        if [ -n "${WALLPAPER}" ] ; then
            pushWallpaper "${WALLPAPER}"
        fi
    fi
}

function deleteTempFontconfig {
    local temp_font_config="$1"
    printVerbose "Deleting temporary fontconfig config file \"${temp_font_config}\""
    rm -f "${temp_font_config}"
}

function testface {
    local sourcewatchface
    if ! sourcewatchface=$(sanitizeSourceWatchface "$1") ; then
        exit 1
    fi
    echo "Testing ${sourcewatchface}"

    WATCHFACE_FONTS_PATH="${SCRIPT_DIRPATH}/${sourcewatchface}/usr/share/fonts/"

    if [ -d "${WATCHFACE_FONTS_PATH}" ]; then
        printVerbose "Watchface has custom fonts in path \"${WATCHFACE_FONTS_PATH}\""

        # Create a temporary fontconfig configuration file that points to the
        # fonts subdirectory of the watchface. This allows Qt to load the font
        # from that local directory - very useful when testing a watch, because
        # then, installing that font is not necessary. The temporary config is
        # generated in the local fontconfig config directory to let fontconfig
        # find it.
        # This is better than setting the FONTCONFIG_FILE environment variable
        # to point to the autogenerated file, because the latter approach will
        # use the autogenerated config file as a full replacement for the system
        # config. This causes the Qt UI itself to not find fonts for its widgets,
        # and can also cause the watchface to not show certain glyphs if they
        # are only available in fallback fonts.

        # Check for the presence of the base fontconfig path. If it does not
        # exist, then the autogenerated config below probably would not work
        # because fontconfig is not present or configured in an unknown fashion.
        # Exit with an error in that case.
        LOCAL_FONTCONFIG_BASE_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/fontconfig"
        if [ ! -d "${LOCAL_FONTCONFIG_BASE_PATH}" ]; then
            echo "Cannot generate temporary fontconfig config file; " \
                 "fontconfig path ${LOCAL_FONTCONFIG_BASE_PATH} does not exist" >&2
            exit 1
        fi

        LOCAL_FONTCONFIG_PATH="${LOCAL_FONTCONFIG_BASE_PATH}/conf.d"
        mkdir -p "$LOCAL_FONTCONFIG_PATH"
        local temp_font_config
        # Use 9999- prefix to make sure this autogenerated configuration is applied
        # last, since fontconfig will list the config files in lexicographic order.
        # Also, the .conf suffix is used, since fontconfig requires that suffix;
        # it ignores files that do not end with ".conf".
        temp_font_config=$(mktemp -p "$LOCAL_FONTCONFIG_PATH" --suffix=".conf"  -t 9999-temp_font_config.XXXXXX) || { echo "Failed to generate temporary fontconfig config file" >&2; exit 1; }

        printVerbose "Generating temporary fontconfig config file \"${temp_font_config}\""

        trap "deleteTempFontconfig \"${temp_font_config}\"" EXIT

        cat <<EOF > "${temp_font_config}"
<?xml version="1.0"?><!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
    <dir>${WATCHFACE_FONTS_PATH}/</dir>
</fontconfig>
EOF
    else
        printVerbose "Watchface has no custom fonts"
    fi

    if [ -n "${WALLPAPER}" ] ; then
        qmlscene "${sourcewatchface}" "${WALLPAPER}" "${WALLPAPER_ROUND}" "${sourcewatchface}/usr/share/asteroid-launcher/watchfaces/" loader.qml -I fake-components
    else
        qmlscene "${sourcewatchface}" "background.jpg" "background-round.jpg" "${sourcewatchface}/usr/share/asteroid-launcher/watchfaces/" loader.qml -I fake-components
    fi
    convertPreviews "${sourcewatchface}"
}

function convertPreviews {
    local watchfacename="$1"
    local transparent="${watchfacename}-trans.png"
    local webResolution=320
    if [ -f "${transparent}" ] ; then
        echo "Converting ${transparent}"
        if ! command -v magick &> /dev/null ; then
            echo "Error: cannot find magick (part of ImageMagick) on path"
            exit 1
        fi
        # generate the transparent thumbnail images for the watch
        for res in 112 128 144 160 182 ; do
            respath="${watchfacename}/usr/share/asteroid-launcher/watchfaces-preview/${res}"
            mkdir -p "${respath}"
            magick "${transparent}" \
                -resize "${res}x${res}" -adaptive-sharpen 0x.8 -quality 70 -strip \
                "${respath}/${watchfacename}.png"
        done
        # generate the thumbnail images for the web
        for thumb in "${watchfacename}" "${watchfacename}-round" ; do
            magick "${thumb}.png" \
                -resize "${webResolution}x${webResolution}" -adaptive-sharpen 0x.4 -quality 85 \
                ".thumbnails/${thumb}.webp"
        done
        # delete the files
        rm "${watchfacename}.png" "${watchfacename}-round.png" "${transparent}"
        echo "| ![thumbnail](.thumbnails/${watchfacename}-round.webp) |![thumbnail](.thumbnails/${watchfacename}.webp) | [${watchfacename}](${watchfacename}/usr/share/asteroid-launcher/watchfaces/${watchfacename}.qml) | [yourname](https://github.com/yourname) |" > "${watchfacename}.md"
        echo "Add the contents of ${watchfacename}.md to README.md, adding font licenses and your name"
    else
        echo "Did not find ${transparent}"
    fi
}
 
function cloneface {
    local sourcewatchface
    local destwatchface="$2"
    if ! sourcewatchface=$(sanitizeSourceWatchface "$1") ; then
        exit 1
    fi
    echo "Cloning ${sourcewatchface} into ${destwatchface}"
    if [ -e "${destwatchface}" ] ; then
        echo "Error:  ${destwatchface} already exists, exiting program"
        exit
    fi
    watchfaceClone "${sourcewatchface}" "${destwatchface}"
}

function yadGuiMenu {
    local watchface
    local action
    local default
    if ! action=$(yad --title="Select action" --height=200 --list --column="action" \
        deploy \
        clone \
        test \
        | awk -F '|' '{print $1}'); then
        exit
    fi
    if [ "${DEFAULTOPTION}" == "ON" ] ; then
        default=TRUE
    else
        default=FALSE
    fi
    case $action in
        deploy)
            declare -a args=('--title=Choose watchfaces' "--width=450" "--height=500" "--list" "--checklist" "--print-column=2" \
                '--column=Selected' '--column=Name' '--column=Preview:IMG')
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${default}" "${wf}" "${wf}/usr/share/asteroid-launcher/watchfaces-preview/112/${wf}.png")
            done
            if ! watchface=$(yad "${args[@]}"); then
                exit
            fi
            watchface=${watchface//|/ }
            ;;
        clone|test)
            declare -a args=('--title=Choose watchfaces' "--width=450" "--height=500" "--list" "--print-column=1" \
                '--column=Name' '--column=Preview:IMG')
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${wf}" "${wf}/usr/share/asteroid-launcher/watchfaces-preview/112/${wf}.png")
            done
            if ! watchface=$(yad "${args[@]}"); then
                exit
            fi
            watchface=${watchface//|}
           ;;
    esac
    # convert | chars to spaces
    if yad --question --title="Confirming" --text="${action} ${watchface}" ; then
        echo "OK!"
        if [ "${action}" = "clone" ] ; then
            if newface=$(yad --entry --title="Cloning ${watchface}" \
                --text="Enter name of new watchface:" \
                --entry-text "newface")
            then cloneface "${watchface}" "${newface}"
            else echo "No name entered"
            fi
        elif [ "${action}" = "deploy" ] ; then
            local first=true
            for wf in ${watchface}; do
                deployface "${wf}" "${first}"
                first=false
            done
            restartCeres
            if [ "${REBOOT}" = "true" ] ; then
                rebootWatch
            fi
        else
            testface "${watchface}"
        fi
    else
        echo "Canceled"
    fi
}

function zenityGuiMenu {
    local watchface
    local action
    local default
    if ! action=$(zenity --title="Select action" --list --radiolist \
        --column="selected" --column="action" \
        TRUE deploy \
        FALSE clone \
        FALSE test); then
        exit
    fi
    if [ "${DEFAULTOPTION}" == "ON" ] ; then
        default=TRUE
    else
        default=FALSE
    fi
    case $action in
        deploy)
            declare -a args=('--title="Choose watchfaces"' "--list" "--checklist" '--column="Selected"' '--column="Name"')
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${default}" "${wf}")
            done
            if ! watchface=$(zenity "${args[@]}"); then
                exit
            fi
            ;;
        clone|test)
            if ! watchface=$(zenity --title="Choose a watchface" --list --column="Name" "${WATCHFACES[@]}"); then
                exit
            fi
            ;;
    esac
    # convert | chars to spaces
    watchface=${watchface//|/ }
    if zenity --question --title="Confirming" --text="${action} ${watchface}" ; then
        echo "OK!"
        if [ "${action}" = "clone" ] ; then
            if newface=$(zenity --entry --title="Cloning ${watchface}" \
                --text="Enter name of new watchface:" \
                --entry-text "newface")
            then cloneface "${watchface}" "${newface}"
            else echo "No name entered"
            fi
        elif [ "${action}" = "deploy" ] ; then
            local first=true
            for wf in ${watchface}; do
                deployface "${wf}" "${first}"
                first=false
            done
            restartCeres
            if [ "${REBOOT}" = "true" ] ; then
                rebootWatch
            fi
        else
            testface "${watchface}"
        fi
    else
        echo "Canceled"
    fi
}

function textMenu {
    local args
    local watchface
    local newface
    if ! action=$(${MENUPROGRAM} --title "Select action" --clear --radiolist \
        "Select action" 0 0 3 \
        "deploy" "Deploy watchface to watch" ON \
        "clone" "Clone watchface to new name" OFF \
        "test" "Test watchface on computer" OFF \
        3>&1 1>&2 2>&3); then
        exit
    fi
    case $action in
        deploy)
            declare -a args=("--title" "Watchfaces" "--clear" "--checklist" "Choose watchfaces:" 25 78 15 "--" )
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${wf}" "" "${DEFAULTOPTION}")
            done
            if ! watchface=$(${MENUPROGRAM} "${args[@]}" 3>&1 1>&2 2>&3); then
                exit
            fi
            ;;
        clone|test)
            declare -a args=("--title" "Watchfaces" "--clear" "--menu" "Choose a watchface:" 25 78 15 "--" )
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${wf}" "")
            done
            if ! watchface=$(${MENUPROGRAM} "${args[@]}" 3>&1 1>&2 2>&3); then
                exit
            fi
            ;;
    esac
    if (${MENUPROGRAM} --clear --title "Confirming" --yesno "${action} ${watchface}" 0 0); then
        echo "OK!"
        if [ "${action}" = "clone" ] ; then
            if newface=$(${MENUPROGRAM} \
                --title "Cloning ${watchface}" --clear \
                --inputbox "Enter name of new watchface:" \
                8 50 "newface" \
                3>&1 1>&2 2>&3)
            then
                cloneface "${watchface}" "${newface}"
            else
                echo "No name entered"
            fi
        elif [ "${action}" = "deploy" ] ; then
            local first=true
            for wf in ${watchface}; do
                deployface "${wf}" "${first}"
                first=false
            done
            if [ "${REBOOT}" = "true" ] ; then
                rebootWatch
            fi
        else
            testface "${watchface}"
        fi
    else
        echo "Canceled"
    fi
}

function deployall {
    for wf in "${WATCHFACES[@]}" ; do
        deployface "${wf}" false
    done
}


(return 0 2>/dev/null) && script_is_sourced=1 || script_is_sourced=0
if [ "$script_is_sourced" -gt 0 ]; then
    echo "You are trying to source this script. It is not meant to be sourced." >&2
    return
fi

# Assume Dialog unless unavailable
if hash dialog 2>/dev/null; then
    MENUPROGRAM="dialog"
elif hash whiptail 2>/dev/null; then
    MENUPROGRAM="whiptail --separate-output"
fi
# location of temporary font directory
FONT_DIR="${HOME}/.fonts"
# Temporary files and symlinks to delete
declare -a DELETE_LIST=()

SCRIPT_DIRPATH="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"

# Preprocess command line switches with getopt to rearrange
# them for easier parsing, separating non-option arguments
# and option arguments.
REARRANGED_OPTS=$(getopt -o 'abc:egqp:r:t:hw:v' --long 'adb,boot,circlewall:,every,gui,qemu,port:,remote:,transport:,help,wall:,verbose' -n "$0" -- "$@")
if [[ $? -ne 0 ]]; then
    echo "Error parsing arguments" >&2
    showHelp
    exit 1
fi
# Replace existing arguments with the rearranged ones
eval set -- "$REARRANGED_OPTS"
unset REARRANGED_OPTS

# Process options
while true; do
    case "$1" in
        '-a'|'--adb')
            ADB=true
            shift
            ;;
        '-b'|'--boot')
            REBOOT=true
            shift
            ;;
        '-c'|'--circlewall')
            WALLPAPER_ROUND="$2"
            shift 2
            ;;
        '-e'|'--every')
            DEFAULTOPTION=ON
            shift
            ;;
        '-g'|'--gui')
            GUI=true
            shift
            ;;
        '-q'|'--qemu')
            WATCHPORT=${QEMUPORT}
            WATCHADDR=${QEMUADDR}
            shift
            ;;
        '-p'|'--port')
            WATCHPORT="$2"
            shift 2
            ;;
        '-r'|'--remote')
            WATCHADDR="$2"
            shift 2
            ;;
        '-t'|'--transport')
            TRANSPORT_ID="-t $2"
            shift 2
            ;;
        '-h'|'--help')
            showHelp
            exit 1
            ;;
        '-w'|'--wall')
            WALLPAPER="$2"
            shift 2
            ;;
        '-v'|'--verbose')
            VERBOSE_MESSAGES=true
            shift
            ;;
        '--')
            shift
            break
            ;;
        *)
            echo "Internal error parsing arguments" >&2
            exit 1
            ;;
    esac
done

# Process remaining arguments as command and its arguments
if [[ $# -gt 0 ]]; then
    COMMAND="$1"
    shift
    COMMAND_ARGS=("$@")
fi

# Validate command and arguments
case "$COMMAND" in
    "clone")
        if [[ ${#COMMAND_ARGS[@]} -ne 2 ]]; then
            echo "Error: clone command requires exactly 2 arguments (source and destination)" >&2
            exit 1
        fi
        ;;
    "deploy"|"test")
        if [[ ${#COMMAND_ARGS[@]} -ne 1 ]]; then
            echo "Error: $COMMAND command requires exactly 1 argument (watchface name)" >&2
            exit 1
        fi
        ;;
    "deployall"|"update"|"version")
        if [[ ${#COMMAND_ARGS[@]} -ne 0 ]]; then
            echo "Error: $COMMAND command takes no arguments" >&2
            exit 1
        fi
        ;;
    "")
        # No command specified - this might be OK for interactive mode
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'" >&2
        showHelp
        exit 1
        ;;
esac

printVerbose "Script is located in directory path \"$SCRIPT_DIRPATH\""

# Execute the command
case "$COMMAND" in
    "clone")
        cloneface "${COMMAND_ARGS[0]}" "${COMMAND_ARGS[1]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "deployall")
        DEPLOY_ALL=true
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "deploy")
        deployface "${COMMAND_ARGS[0]}" true
        restartCeres
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "test")
        testface "${COMMAND_ARGS[0]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "update")
        git pull
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "version")
        showVersion
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "")
        # No command - continue with interactive mode
        echo "No command specified, entering interactive mode"
        ;;
esac

# If needed, start the interactive dialog, either via TUI or via GUI.
mapfile -t WATCHFACES < <(find . -maxdepth 3 -type d -path "*/usr/share" -printf "%h\n" | sort | awk -F '/' '{print $2}' )
if [ "${SKIP_INTERACTIVE_PROMPT}" != "true" ] ; then
    if [ "${GUI}" = "true" ] ; then
        if hash yad 2>/dev/null; then
            yadGuiMenu
        elif hash zenity 2>/dev/null; then
            zenityGuiMenu
        else
            echo "Error: install 'yad' or'zenity' to use gui menus."
        fi
    else
        if [ -z "${MENUPROGRAM}" ] ; then
            echo "Error: install either 'dialog' or 'whiptail' to use text menus."
        else
            textMenu
        fi
    fi
elif [ "${DEPLOY_ALL}" == "true" ] ; then
    deployall
fi
